<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/assets/main.css">
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Albert Mata</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          <a class="page-link" href="/">Home</a><a class="page-link" href="/notes/">Notes</a><a class="page-link" href="/skills/">Skills</a><a class="page-link" href="/resume/">Resume</a><a class="page-link" href="/privacy/">Privacy</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">FunProg week 6: Collections</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2013-03-12T00:00:00+01:00" itemprop="datePublished">Mar 12, 2013
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><em>In September 2012, I enrolled in the course <a href="https://www.coursera.org/course/progfun">Functional Programming Principles in Scala</a> given by Martin Odersky at Coursera. In that course I learnt about functional programming and how it can be effectively combined with object-oriented programming. The series [FunProg week] are my compiled notes from that course.</em></p>

<h2 id="vectors">Vectors</h2>

<p>We have seen that lists are linear: access to the first element is much faster than access to the middle or end of a list. Vectors, on the other hand, have more evenly balanced access patterns.</p>

<p>A vector is constructed using an array of maximum 32 elements. If it needs to contain more than 32 elements, it becomes an array of 32 pointers to 32 arrays of 32 elements. And so on -adding levels- until there is space for all the elements. So a depth of six can handle around a billion elements.</p>

<p>Access to random elements in a vector is related to its depth, so obviously it’s very efficient. Lists are a better choice when we use a pattern where we use a list’s head and a tail. Otherwise vectors are generally a better choice.</p>

<p>We create vectors in a similar way to lists:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">nums</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">people</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">,</span> <span class="s">"James"</span><span class="o">,</span> <span class="s">"Peter"</span><span class="o">)</span>
</code></pre></div></div>

<p>And they support the same operations as lists, with the exception of <code class="language-plaintext highlighter-rouge">::</code> (but we can use <code class="language-plaintext highlighter-rouge">x +: xs</code> or <code class="language-plaintext highlighter-rouge">xs :+ x</code> instead to create a new vector with a new element at the beginning or the end of previous vector). Please note that vectors are immutable, so when we say we modify them we are actually creating a new one.</p>

<h2 id="ranges">Ranges</h2>

<p>Ranges are another simple kind of sequence that represent a sequence of evenly spaced integers using <code class="language-plaintext highlighter-rouge">to</code> (inclusive), <code class="language-plaintext highlighter-rouge">until</code> (exclusive) and <code class="language-plaintext highlighter-rouge">by</code> (to determine step value). Ranges are represented as single objects with three fields: lower bound, upper bound and step value.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">r</span><span class="k">:</span> <span class="kt">Range</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">5</span> <span class="c1">// 1, 2, 3, 4</span>
<span class="k">val</span> <span class="nv">s</span><span class="k">:</span> <span class="kt">Range</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span>    <span class="c1">// 1, 2, 3, 4, 5</span>
<span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span> <span class="n">by</span> <span class="mi">3</span>             <span class="c1">// 1, 4, 7, 10</span>
<span class="mi">6</span> <span class="n">to</span> <span class="mi">1</span> <span class="n">by</span> <span class="o">-</span><span class="mi">2</span>             <span class="c1">// 6, 4, 2</span>
</code></pre></div></div>

<h2 id="operations-on-sequences">Operations on sequences</h2>

<p>Sequences have a lot of available methods that can be found at <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.Seq">Scala Standard Library</a>, being these some of the most common:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">xs exists p</code> returns true if the sequence contains any element satisfying the predicate,</li>
  <li><code class="language-plaintext highlighter-rouge">xs forall p</code> returns true if all elements in the sequence satisfy the predicate,</li>
  <li><code class="language-plaintext highlighter-rouge">xs zip ys</code> returns a sequence of pairs taking one element from each sequence for each pair (the sequence with less elements will set the length of the sequence sequence of pairs),</li>
  <li><code class="language-plaintext highlighter-rouge">xs.unzip</code> returns two sequences from a sequence of pairs,</li>
  <li><code class="language-plaintext highlighter-rouge">xs.flatMap f</code> applies function <code class="language-plaintext highlighter-rouge">f</code> to all elements in the sequence and concatenates the results,</li>
  <li><code class="language-plaintext highlighter-rouge">xs.sum</code> returns the sum of all elements in the sequence,</li>
  <li><code class="language-plaintext highlighter-rouge">xs.product</code> returns the product of all elements in the sequence,</li>
  <li><code class="language-plaintext highlighter-rouge">xs.max</code> returns the maximum of all elements in the sequence (an <code class="language-plaintext highlighter-rouge">Ordering</code> is required),</li>
  <li><code class="language-plaintext highlighter-rouge">xs.min</code> returns the maximum of all elements in the sequence (an <code class="language-plaintext highlighter-rouge">Ordering</code> is required).</li>
</ul>

<h2 id="some-examples">Some examples</h2>

<p>Let’s see how we could get all combinations of numbers <code class="language-plaintext highlighter-rouge">x</code> (from 1 to M) and <code class="language-plaintext highlighter-rouge">y</code> (from 1 to N):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">M</span> <span class="k">=</span> <span class="mi">3</span>
<span class="k">val</span> <span class="nv">N</span> <span class="k">=</span> <span class="mi">5</span>   
<span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">M</span><span class="o">)</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">N</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)))</span>
<span class="c1">//&gt; Vector((1,1), (1,2), (1,3), (1,4), (1,5), </span>
<span class="c1">//&gt;        (2,1), (2,2), (2,3), (2,4), (2,5), </span>
<span class="c1">//&gt;        (3,1), (3,2), (3,3), (3,4), (3,5))</span>
</code></pre></div></div>

<p>And now how we could compute the scalar product of two vectors:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">scalarProduct1</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Double</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
  <span class="o">(</span><span class="n">xs</span> <span class="n">zip</span> <span class="n">ys</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">xy</span> <span class="k">=&gt;</span> <span class="nv">xy</span><span class="o">.</span><span class="py">_1</span> <span class="o">*</span> <span class="nv">xy</span><span class="o">.</span><span class="py">_2</span><span class="o">).</span><span class="py">sum</span>
</code></pre></div></div>

<p>Or same thing using patter matching function value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">scalarProduct2</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Double</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
  <span class="o">(</span><span class="n">xs</span> <span class="n">zip</span> <span class="n">ys</span><span class="o">).</span><span class="py">map</span><span class="o">{</span> <span class="nf">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">}.</span><span class="py">sum</span>
</code></pre></div></div>

<p>And how we could say if a number is prime (that is, its only divisors are 1 and the number itself):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">isPrime</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">(</span><span class="mi">2</span> <span class="n">until</span> <span class="n">n</span><span class="o">)</span> <span class="nf">forall</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="k">_</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>

<span class="nf">isPrime</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span>  <span class="c1">// true</span>
<span class="nf">isPrime</span><span class="o">(</span><span class="mi">14</span><span class="o">)</span> <span class="c1">// false</span>
</code></pre></div></div>

<h2 id="collection-hierarchy">Collection hierarchy</h2>

<p><code class="language-plaintext highlighter-rouge">List</code> and <code class="language-plaintext highlighter-rouge">Vector</code> have a common base class, <code class="language-plaintext highlighter-rouge">Seq</code>, which is actually the class of all sequences. And <code class="language-plaintext highlighter-rouge">Seq</code> itself is a subclass of <code class="language-plaintext highlighter-rouge">Iterable</code> same way as <code class="language-plaintext highlighter-rouge">Set</code> and <code class="language-plaintext highlighter-rouge">Map</code> are.</p>

<p><code class="language-plaintext highlighter-rouge">Array</code> and <code class="language-plaintext highlighter-rouge">String</code> support the same operations as <code class="language-plaintext highlighter-rouge">Seq</code> and can implicitly be converted to sequences where needed, but are not direct subclasses of <code class="language-plaintext highlighter-rouge">Seq</code> because they come directly from Java. Anyway we can do things like these:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">xs</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">xs</span> <span class="nf">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="o">)</span> <span class="c1">// Array(2, 4, 6)</span>

<span class="k">val</span> <span class="nv">ys</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"Hello World!"</span>
<span class="n">ys</span> <span class="nf">filter</span> <span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">isUpper</span><span class="o">)</span> <span class="c1">// "HW"</span>
</code></pre></div></div>

<p>This is a simplification of the hierarchy we’ve seen so far:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Iterable</span>

<span class="nc">Map</span> <span class="o">-&gt;</span> <span class="nc">Iterable</span>
<span class="nc">Set</span> <span class="o">-&gt;</span> <span class="nc">Iterable</span>
<span class="nc">Seq</span> <span class="o">-&gt;</span> <span class="nc">Iterable</span>

<span class="nc">List</span>   <span class="o">-&gt;</span> <span class="nc">Seq</span>
<span class="nc">Vector</span> <span class="o">-&gt;</span> <span class="nc">Seq</span>
<span class="nc">Range</span>  <span class="o">-&gt;</span> <span class="nc">Seq</span>

<span class="nc">String</span> <span class="o">~&gt;</span> <span class="nc">Seq</span>
<span class="nc">Array</span>  <span class="o">~&gt;</span> <span class="nc">Seq</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">-&gt;</code> means “it’s subclass of”, <code class="language-plaintext highlighter-rouge">~&gt;</code> means “it’s not subclass of, but very works as if it was”.</p>

<h2 id="combinatorial-search">Combinatorial search</h2>

<p>Higher order functions on collections often replace loops on imperative languages.</p>

<p>Let’s see that with an example. Say we have a positive integer <code class="language-plaintext highlighter-rouge">n</code> and want to find all pairs of positive integers <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> such that <code class="language-plaintext highlighter-rouge">i + j</code> is prime and `1 &lt;= j &lt; i &lt; n’. For example, for 7 the sought pairs are these ones:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i: 2  3  4  4  5  6  6
j: 1  2  1  3  2  1  5
</code></pre></div></div>

<p>In imperative languages we can use two nested loops, one for <code class="language-plaintext highlighter-rouge">i</code> and one for <code class="language-plaintext highlighter-rouge">j</code> and check their sum on each iteration to see if we need to store that combination in any kind of collection.</p>

<p>In a functional language we look for a more natural way to do the same: first we generate the sequence of all pairs of integers fulfilling the <code class="language-plaintext highlighter-rouge">1 &lt;= j &lt; i &lt; n' condition; after that we filter the pairs for which</code>i + j` is prime.</p>

<p>For the first part we can use some tools on sequences we’ve seen before and write this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">n</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span>
  <span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">i</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)))</span>
</code></pre></div></div>

<p>If we try this (i.e. in a Scala Worksheet) we’ll see we get a vector of vectors of pairs, but we actually just want a single collection of pairs.</p>

<p>To achieve this, we can use the <code class="language-plaintext highlighter-rouge">foldRight</code> method we saw in previous sessions and the concatenation operation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="n">xss</span> <span class="n">foldRight</span> <span class="nc">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]())(</span><span class="k">_</span> <span class="o">++</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>We use the <code class="language-plaintext highlighter-rouge">xss</code> notation to show its a collection of collections. There’s actually a built-in method to do exactly this same operation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">xss</span><span class="o">.</span><span class="py">flatten</span>
</code></pre></div></div>

<p>So we can rewrite previous code as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">((</span><span class="mi">1</span> <span class="n">until</span> <span class="n">n</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span>
  <span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">i</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)))).</span><span class="py">flatten</span>
</code></pre></div></div>

<p>And we’ll get a vector of pairs (so a simple collection of pairs, which is what we wanted).</p>

<p>There’s another way to achieve the same, taking into account that:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xs</span> <span class="n">flatMap</span> <span class="n">f</span> <span class="k">=</span> <span class="o">(</span><span class="n">xs</span> <span class="n">map</span> <span class="n">f</span><span class="o">).</span><span class="py">flatten</span>
</code></pre></div></div>

<p>So our code can be written this way:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">n</span><span class="o">)</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span>
  <span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">i</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)))</span>
</code></pre></div></div>

<p>The first part of our problem is solved: generating the sequence of all paris of integers fulfilling the <code class="language-plaintext highlighter-rouge">1 &lt;= j &lt; i &lt; n</code> condition. Now we want to filter the pairs for which <code class="language-plaintext highlighter-rouge">i + j</code> is prime. To do that we can simply use the <code class="language-plaintext highlighter-rouge">filter</code> method:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">n</span><span class="o">)</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span>
  <span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">i</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)))</span> <span class="nf">filter</span> <span class="o">(</span><span class="n">pair</span> <span class="k">=&gt;</span>
	<span class="nf">isPrime</span><span class="o">(</span><span class="nv">pair</span><span class="o">.</span><span class="py">_1</span> <span class="o">+</span> <span class="nv">pair</span><span class="o">.</span><span class="py">_2</span><span class="o">))</span>
</code></pre></div></div>

<p>And we finally get a collection with all pairs which fulfil the condition.</p>

<p>OK, this already works, but it’s not very easy to follow and understand, it’s probably less clear than the imperative language approach in fact. That’s why we have For expressions.</p>

<h2 id="for-expressions">For expressions</h2>

<p>Higher order functions such as <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">flatMap</code> or <code class="language-plaintext highlighter-rouge">filter</code> provide powerful constructs for manipulating lists. But sometimes the level of abstraction required by these functions make the program difficult to understand. In these situations, the <code class="language-plaintext highlighter-rouge">for</code> expression can help.</p>

<p>Imagine we have a <code class="language-plaintext highlighter-rouge">persons</code> list of elements of a class as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</code></pre></div></div>

<p>To get the names of all persons over 20 years old we could write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">persons</span> <span class="nf">filter</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="nv">p</span><span class="o">.</span><span class="py">age</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="nv">p</span><span class="o">.</span><span class="py">name</span><span class="o">)</span>
</code></pre></div></div>

<p>But we can instead use a <code class="language-plaintext highlighter-rouge">for</code> expression:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">for</span> <span class="o">(</span><span class="n">p</span> <span class="k">&lt;-</span> <span class="n">persons</span> <span class="k">if</span> <span class="nv">p</span><span class="o">.</span><span class="py">age</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="o">)</span> <span class="k">yield</span> <span class="nv">p</span><span class="o">.</span><span class="py">name</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">for</code> expression is similar to loops in imperative languages, except that it builds a list of the results of all iterations.</p>

<p>A <code class="language-plaintext highlighter-rouge">for</code> expressions is always of the form:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">for</span> <span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">yield</span> <span class="n">e</span>
</code></pre></div></div>

<p>Where <code class="language-plaintext highlighter-rouge">s</code> is a sequence of generators and filters and <code class="language-plaintext highlighter-rouge">e</code> is an expression whose value is returned by an iteration (<code class="language-plaintext highlighter-rouge">yield</code> sets what we want to produce with the expression):</p>

<ul>
  <li>a generator is of the form <code class="language-plaintext highlighter-rouge">p &lt;- e</code> where <code class="language-plaintext highlighter-rouge">p</code> is a pattern and <code class="language-plaintext highlighter-rouge">e</code> an expression whose value is a collection,</li>
  <li>a filter is of the form <code class="language-plaintext highlighter-rouge">if f</code> where <code class="language-plaintext highlighter-rouge">f</code> is a boolean expression,</li>
  <li>the sequence must start with a generator,</li>
  <li>if there are several generators in the sequence, the last generators vary faster than the first.</li>
</ul>

<p>Instead of <code class="language-plaintext highlighter-rouge">(s)</code>, we can write <code class="language-plaintext highlighter-rouge">{s}</code> and then the sequence of generators and filters can be written on multiple lines without requiring semicolons.</p>

<p>Let’s see now how we can solve our previous problem (pairs where the sum of both numbers is prime) using a <code class="language-plaintext highlighter-rouge">for</code> expression:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">n</span>
  <span class="n">j</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">i</span>
  <span class="k">if</span> <span class="nf">isPrime</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">)</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span>
</code></pre></div></div>

<p>This is obviously a much cleaner and easy to understand implementation.</p>

<p>Finally, this is a <code class="language-plaintext highlighter-rouge">for</code> expression for the <code class="language-plaintext highlighter-rouge">scalarProduct</code> we saw in previous session:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">scalarProduct</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Double</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
  <span class="o">(</span><span class="nf">for</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">xs</span> <span class="n">zip</span> <span class="n">ys</span><span class="o">)</span> <span class="k">yield</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">).</span><span class="py">sum</span>
</code></pre></div></div>

<h2 id="sets">Sets</h2>

<p>In previous sessions we showed this basic collection hierarchy:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Iterable</span>

<span class="nc">Map</span> <span class="o">-&gt;</span> <span class="nc">Iterable</span>
<span class="nc">Set</span> <span class="o">-&gt;</span> <span class="nc">Iterable</span>
<span class="nc">Seq</span> <span class="o">-&gt;</span> <span class="nc">Iterable</span>

<span class="nc">List</span>   <span class="o">-&gt;</span> <span class="nc">Seq</span>
<span class="nc">Vector</span> <span class="o">-&gt;</span> <span class="nc">Seq</span>
<span class="nc">Range</span>  <span class="o">-&gt;</span> <span class="nc">Seq</span>

<span class="nc">String</span> <span class="o">~&gt;</span> <span class="nc">Seq</span>
<span class="nc">Array</span>  <span class="o">~&gt;</span> <span class="nc">Seq</span>
</code></pre></div></div>

<p>So we’re now taking a look at sets. We can construct them easily:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">fruit</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"banana"</span><span class="o">,</span> <span class="s">"pear"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">6</span><span class="o">).</span><span class="py">toSet</span>
</code></pre></div></div>

<p>And most operations on sequences are also available on sets. Nevertheless, there are some principal differences between sets and sequences:</p>

<ul>
  <li>sets are unordered (the elements of a set do not have a predefined order in which they appear in the set),</li>
  <li>sets do not have duplicate elements,</li>
  <li>the fundamental operation on sets is <code class="language-plaintext highlighter-rouge">contains</code>.</li>
</ul>

<h2 id="n-queens-problem">N queens problem</h2>

<p>A classical problem in computing is the eight queens problem (or, more in general, N queens problem) which consists in placing queens on a chessboard so that no one is threatened by another. For example, for N = 4:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>: X : :    row 0 col 1
: : : X    row 1 col 3
X : : :    row 2 col 0
: : X :    row 3 col 2
</code></pre></div></div>

<p>This is just a valid solution, but our goal is to find a set with all the possible solutions.</p>

<p>We can solve this problem with a recursive algorithm:</p>

<ol>
  <li>Suppose that we have already generated all the solutions consisting of placing k-1 queens on a board of size n.</li>
  <li>Each solution is represented by a list (of length k-1) containing the numbers of columns (between 0 and n-1).</li>
  <li>The column number of the queen in k-1 row comes first in the list, followed by the column number of the queen in row k-2, etc. So, in our previous example, List(0, 3, 1).</li>
  <li>The solution set is thus represented as a set of lists, with one element for each solution.</li>
  <li>Now, to place the k-th queen, we generate all possible extensions of each solution preceded by a new queen.</li>
</ol>

<p>So, in code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">queens</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">placeQueens</span><span class="o">(</span><span class="n">k</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">Set</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>
	<span class="k">else</span> 
	  <span class="k">for</span> <span class="o">{</span>
		<span class="n">queens</span> <span class="k">&lt;-</span> <span class="nf">placeQueens</span><span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
		<span class="n">col</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">n</span>
		<span class="k">if</span> <span class="nf">isSafe</span><span class="o">(</span><span class="n">col</span><span class="o">,</span> <span class="n">queens</span><span class="o">)</span>
	  <span class="o">}</span> <span class="k">yield</span> <span class="n">col</span> <span class="o">::</span> <span class="n">queens</span>
  <span class="nf">placeQueens</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We need a function to know if a queen is safe in a concrete column with a current queens distribution:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">isSafe</span><span class="o">(</span><span class="n">col</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">queens</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">row</span> <span class="k">=</span> <span class="nv">queens</span><span class="o">.</span><span class="py">length</span> <span class="c1">// (1)</span>
  <span class="k">val</span> <span class="nv">queensWithRow</span> <span class="k">=</span> <span class="o">(</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">0</span> <span class="n">by</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">zip</span> <span class="n">queens</span> <span class="c1">// (2)</span>
  <span class="n">queensWithRow</span> <span class="n">forall</span> <span class="o">{</span>
	<span class="nf">case</span> <span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">col</span> <span class="o">!=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="nv">math</span><span class="o">.</span><span class="py">abs</span><span class="o">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">c</span><span class="o">)</span> <span class="o">!=</span> <span class="n">row</span> <span class="o">-</span> <span class="n">r</span> <span class="c1">// (3)  </span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In (1) we give a row value to the new queen.</p>

<p>In (2) we convert a list like <code class="language-plaintext highlighter-rouge">List(0, 3, 1)</code> into a new list of pairs with rows included (row, column) <code class="language-plaintext highlighter-rouge">List((2,0), (1,3), (0,1))</code>.</p>

<p>In (3) we check that the new column is not the same as any other’s queen’s column and that there is no diagonal between the new queen and any other.</p>

<p>Finally we just need a function to show the results in a graphic representation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">show</span><span class="o">(</span><span class="n">queens</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">lines</span> <span class="k">=</span>
	<span class="nf">for</span> <span class="o">(</span><span class="n">col</span> <span class="k">&lt;-</span> <span class="nv">queens</span><span class="o">.</span><span class="py">reverse</span><span class="o">)</span>
	<span class="k">yield</span> <span class="nv">Vector</span><span class="o">.</span><span class="py">fill</span><span class="o">(</span><span class="nv">queens</span><span class="o">.</span><span class="py">length</span><span class="o">)(</span><span class="s">": "</span><span class="o">).</span><span class="py">updated</span><span class="o">(</span><span class="n">col</span><span class="o">,</span><span class="s">"X "</span><span class="o">).</span><span class="py">mkString</span> 
  <span class="s">"\n"</span> <span class="o">+</span> <span class="o">(</span><span class="n">lines</span> <span class="n">mkString</span> <span class="s">"\n"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And for N = 4 we get:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>: : X : 
X : : : 
: : : X 
: X : : 

: X : : 
: : : X 
X : : : 
: : X :
</code></pre></div></div>

<p>The second solution is the one we showed at the beginning of this problem. The first one is a new solution that our algorithm has found. If we increase the value of N we’ll find more and more different solutions.</p>

<h2 id="queries-with-for">Queries with for</h2>

<p>If we analyze <code class="language-plaintext highlighter-rouge">for</code> expressions we’ve seen so far, they look a little bit like database queries. For instance, imagine we have a class <code class="language-plaintext highlighter-rouge">Book</code> as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Book</span><span class="o">(</span><span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">authors</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span>
</code></pre></div></div>

<p>We could create a little database with a simple list:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">books</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
  <span class="nc">Book</span><span class="o">(</span><span class="n">title</span> <span class="k">=</span> <span class="s">"book1 cs"</span><span class="o">,</span> <span class="n">authors</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"author11"</span><span class="o">,</span> <span class="s">"author12"</span><span class="o">)),</span>
  <span class="nc">Book</span><span class="o">(</span><span class="n">title</span> <span class="k">=</span> <span class="s">"book2 maths"</span><span class="o">,</span> <span class="n">authors</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"author21"</span><span class="o">)),</span>
  <span class="nc">Book</span><span class="o">(</span><span class="n">title</span> <span class="k">=</span> <span class="s">"book3 cs"</span><span class="o">,</span> <span class="n">authors</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"author31"</span><span class="o">,</span> <span class="s">"author32"</span><span class="o">,</span> <span class="s">"author33"</span><span class="o">)),</span>
  <span class="nc">Book</span><span class="o">(</span><span class="n">title</span> <span class="k">=</span> <span class="s">"book4"</span><span class="o">,</span> <span class="n">authors</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"author11"</span><span class="o">)))</span>
</code></pre></div></div>

<p>Which is exactly the same as this other expression, just clearer:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">books</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
  <span class="nc">Book</span><span class="o">(</span><span class="s">"book1 cs"</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="s">"author11"</span><span class="o">,</span> <span class="s">"author12"</span><span class="o">)),</span> <span class="o">...)</span>
</code></pre></div></div>

<p>We can now ask for the titles whose author is “author32”:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">for</span> <span class="o">(</span><span class="n">b</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> <span class="n">a</span> <span class="k">&lt;-</span> <span class="nv">b</span><span class="o">.</span><span class="py">authors</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="s">"author32"</span><span class="o">)</span> 
<span class="k">yield</span> <span class="nv">b</span><span class="o">.</span><span class="py">title</span>
</code></pre></div></div>

<p>Note that there is an iteration on the books and another on the authors of any book.</p>

<p>Or the books with the word “cs” in the title:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">for</span> <span class="o">(</span><span class="n">b</span> <span class="k">&lt;-</span> <span class="n">books</span> <span class="k">if</span> <span class="nv">b</span><span class="o">.</span><span class="py">title</span> <span class="n">indexOf</span> <span class="s">"cs"</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> 
<span class="k">yield</span> <span class="nv">b</span><span class="o">.</span><span class="py">title</span>
</code></pre></div></div>

<p>A more complicated query could be this one, to get the names of all authors that have written at least two books:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="n">b1</span> <span class="k">&lt;-</span> <span class="n">books</span>
  <span class="n">b2</span> <span class="k">&lt;-</span> <span class="n">books</span>
  <span class="k">if</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b2</span>
  <span class="n">a1</span> <span class="k">&lt;-</span> <span class="nv">b1</span><span class="o">.</span><span class="py">authors</span>
  <span class="n">a2</span> <span class="k">&lt;-</span> <span class="nv">b2</span><span class="o">.</span><span class="py">authors</span>
  <span class="k">if</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">a1</span>
</code></pre></div></div>

<p>This gets the correct result, but duplicated, because it iterates all books both in <code class="language-plaintext highlighter-rouge">b1</code> and in <code class="language-plaintext highlighter-rouge">b2</code>, so it creates all combination of books twice (in reversed order).</p>

<p>To avoid this, a first way would be to require that <code class="language-plaintext highlighter-rouge">b1.title &lt; b2.title</code> instead of just <code class="language-plaintext highlighter-rouge">b1 != b2</code>. We still will have all combinations duplicated, but just produce results for one of them. But this is not a good enough solution, as if an author writes three books, let’s say A, B and C, the condition will be satisfied for A &lt; B, A &lt; C and B &lt; C, so again it will be shown more than once.</p>

<p>Another way, better, to solve that little problem is to use <code class="language-plaintext highlighter-rouge">distinct</code> method:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span> <span class="k">for</span> <span class="o">{</span>
	<span class="n">b1</span> <span class="k">&lt;-</span> <span class="n">books</span>
	<span class="n">b2</span> <span class="k">&lt;-</span> <span class="n">books</span>
	<span class="k">if</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b2</span>
	<span class="n">a1</span> <span class="k">&lt;-</span> <span class="nv">b1</span><span class="o">.</span><span class="py">authors</span>
	<span class="n">a2</span> <span class="k">&lt;-</span> <span class="nv">b2</span><span class="o">.</span><span class="py">authors</span>
	<span class="k">if</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a1</span>
<span class="o">).</span><span class="py">distinct</span>
</code></pre></div></div>

<p>And the probably best option would be to define <code class="language-plaintext highlighter-rouge">books</code> from the very beginning as a <code class="language-plaintext highlighter-rouge">Set</code> instead of a <code class="language-plaintext highlighter-rouge">List</code>, so when we use <code class="language-plaintext highlighter-rouge">for</code> expressions we would get sets as well, and as sets can’t have duplicate values we’ll solve the problem.</p>

<h2 id="for-expressions-and-higher-order-functions">For expressions and higher order functions</h2>

<p>For expressions are very related to the higher order functions <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">flatMap</code> and <code class="language-plaintext highlighter-rouge">filter</code>. These functions can actually be defined in terms of <code class="language-plaintext highlighter-rouge">for</code>. But in realitiy, the Scala compiler does the opposite: it expresses for expressions in terms of higher order functions.</p>

<p>So when we write these expressions, the Scala compiler translates them into their equivalences:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">e1</span><span class="o">)</span> <span class="k">yield</span> <span class="nf">e2</span> 
<span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="nv">e1</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">e2</span><span class="o">)</span>

<span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">e1</span> <span class="k">if</span> <span class="n">f</span><span class="o">;</span> <span class="n">s</span><span class="o">)</span> <span class="k">yield</span> <span class="nf">e2</span> 
<span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="nv">e1</span><span class="o">.</span><span class="py">withFilter</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">);</span> <span class="n">s</span><span class="o">)</span> <span class="k">yield</span> <span class="nf">e2</span>

<span class="o">(</span><span class="mi">3</span><span class="o">)</span> <span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">e1</span><span class="o">;</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="n">e2</span><span class="o">;</span> <span class="n">s</span><span class="o">)</span> <span class="k">yield</span> <span class="nf">e3</span>
<span class="o">(</span><span class="mi">3</span><span class="o">)</span> <span class="nv">e1</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">for</span> <span class="o">(</span><span class="n">y</span> <span class="k">&lt;-</span> <span class="n">e2</span><span class="o">;</span> <span class="n">s</span><span class="o">)</span> <span class="k">yield</span> <span class="n">e3</span><span class="o">)</span>
</code></pre></div></div>

<p>In (1) we translate a <code class="language-plaintext highlighter-rouge">for</code> expression into a <code class="language-plaintext highlighter-rouge">map</code> expression. In (2) and (3) we translate <code class="language-plaintext highlighter-rouge">for</code> expressions into new <code class="language-plaintext highlighter-rouge">for</code> expressions with less elements.</p>

<p>We actually saw this with a previous example where we wanted to get pairs of numbers whose sum was prime and got these two solutions:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">n</span>
  <span class="n">j</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">i</span>
  <span class="k">if</span> <span class="nf">isPrime</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span><span class="n">j</span><span class="o">)</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span>

<span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">n</span><span class="o">)</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span>
  <span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">i</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)))</span> <span class="nf">filter</span> <span class="o">(</span><span class="n">pair</span> <span class="k">=&gt;</span>
	<span class="nf">isPrime</span><span class="o">(</span><span class="nv">pair</span><span class="o">.</span><span class="py">_1</span> <span class="o">+</span> <span class="nv">pair</span><span class="o">.</span><span class="py">_2</span><span class="o">))</span>
</code></pre></div></div>

<p>Taking a look at them, we do check that for expressions can be expressed in terms of higher order functions <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">flatMap</code> and <code class="language-plaintext highlighter-rouge">filter</code>.</p>

<p>Or, another example, our previous query to get books written by an author:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">for</span> <span class="o">(</span><span class="n">b</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> <span class="n">a</span> <span class="k">&lt;-</span> <span class="nv">b</span><span class="o">.</span><span class="py">authors</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="s">"author32"</span><span class="o">)</span> 
<span class="k">yield</span> <span class="nv">b</span><span class="o">.</span><span class="py">title</span>
</code></pre></div></div>

<p>Can also be expressed using higher order functions as follows (process shows step by step substitution):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Original query</span>
<span class="nf">for</span> <span class="o">(</span><span class="n">b</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> <span class="n">a</span> <span class="k">&lt;-</span> <span class="nv">b</span><span class="o">.</span><span class="py">authors</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="s">"author32"</span><span class="o">)</span>
<span class="k">yield</span> <span class="nv">b</span><span class="o">.</span><span class="py">title</span>

<span class="c1">// (3) for (x &lt;- e1; y &lt;- e2; s) yield e3</span>
<span class="c1">// (3) e1.flatMap(x =&gt; for (y &lt;- e2; s) yield e3)</span>
<span class="n">books</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">b</span> <span class="k">=&gt;</span>
  <span class="nf">for</span><span class="o">(</span><span class="n">a</span> <span class="k">&lt;-</span> <span class="nv">b</span><span class="o">.</span><span class="py">authors</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="s">"author32"</span><span class="o">)</span> <span class="k">yield</span> <span class="nv">b</span><span class="o">.</span><span class="py">title</span><span class="o">)</span>

<span class="c1">// (2) for (x &lt;- e1 if f; s) yield e2</span>
<span class="c1">// (2) for (x &lt;- e1.withFilter(x =&gt; f); s) yield e2</span>
<span class="n">books</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">b</span> <span class="k">=&gt;</span>
  <span class="nf">for</span><span class="o">(</span><span class="n">a</span> <span class="k">&lt;-</span> <span class="nv">b</span><span class="o">.</span><span class="py">authors</span><span class="o">.</span><span class="py">withFilter</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">==</span> <span class="s">"author32"</span><span class="o">))</span> <span class="k">yield</span> <span class="nv">b</span><span class="o">.</span><span class="py">title</span><span class="o">)</span>

<span class="c1">// (1) for (x &lt;- e1) yield e2</span>
<span class="c1">// (1) e1.map(x =&gt; e2)</span>
<span class="n">books</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">b</span> <span class="k">=&gt;</span>
  <span class="nv">b</span><span class="o">.</span><span class="py">authors</span><span class="o">.</span><span class="py">withFilter</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">==</span> <span class="s">"author32"</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nv">b</span><span class="o">.</span><span class="py">title</span><span class="o">))</span>
</code></pre></div></div>

<p>The translation of <code class="language-plaintext highlighter-rouge">for</code> is not limited to lists or sequences, but is based solely on the presence of the methods <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">flatMap</code> and <code class="language-plaintext highlighter-rouge">withFilter</code>. So we can use the <code class="language-plaintext highlighter-rouge">for</code> syntax with our own types as long as we define these three functions for them. These are similar ideas to those used in Microsoft’s LINQ.</p>

<h2 id="maps">Maps</h2>

<p>A map of type <code class="language-plaintext highlighter-rouge">Map[Key, Value]</code> is an immutable data structure that associates keys of type <code class="language-plaintext highlighter-rouge">Key</code> with values of type <code class="language-plaintext highlighter-rouge">Value</code>. For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">romanLetters</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"I"</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">"V"</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="o">,</span> <span class="s">"X"</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">romanNumbers</span> <span class="k">=</span> <span class="n">romanLetters</span> <span class="n">map</span> <span class="o">{</span>
  <span class="nf">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But maps can also be used everywhere functions can, as class <code class="language-plaintext highlighter-rouge">Map[Key, Value]</code> extends the function type <code class="language-plaintext highlighter-rouge">Key =&gt; Value</code>. So everywhere we need one, we can use the other.</p>

<p>We can retrieve a value using this syntax:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">romanNumbers</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span> <span class="c1">// "V"</span>
</code></pre></div></div>

<p>But if key doesn’t exist it will thrown an exception. So it’s probably a better idea to use this other syntax that returns the value or a <code class="language-plaintext highlighter-rouge">None</code> if there is no match:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">romanNumbers</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>     <span class="c1">//&gt; res0: java.lang.String = V</span>
<span class="n">romanNumbers</span> <span class="n">get</span> <span class="mi">5</span>  <span class="c1">//&gt; res1: Option[java.lang.String] = Some(V)</span>
<span class="n">romanNumbers</span> <span class="n">get</span> <span class="mi">6</span>  <span class="c1">//&gt; res2: Option[java.lang.String] = None</span>
</code></pre></div></div>

<h2 id="the-option-type">The Option type</h2>

<p>Please note that previous code returns values of type <code class="language-plaintext highlighter-rouge">Option</code>. The <code class="language-plaintext highlighter-rouge">Option</code> type is defined as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">Some</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">object</span> <span class="nc">None</span> <span class="k">extends</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</code></pre></div></div>

<p>So our previous <code class="language-plaintext highlighter-rouge">map get key</code> expressions return <code class="language-plaintext highlighter-rouge">None</code> if there is no value for the given key or <code class="language-plaintext highlighter-rouge">Some(x)</code> if there is a value.</p>

<p>Since options are defined as case classes, they can be decomposed using pattern matching:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">showRoman</span><span class="o">(</span><span class="n">number</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">romanNumbers</span> <span class="nf">get</span><span class="o">(</span><span class="n">number</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">letter</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">letter</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="s">"no Roman letter for this number"</span>
<span class="o">}</span>
<span class="nf">showRoman</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>  <span class="c1">//&gt; res3: java.lang.String = X</span>
<span class="nf">showRoman</span><span class="o">(</span><span class="mi">13</span><span class="o">)</span>  <span class="c1">//&gt; res4: java.lang.String = no Roman letter for this number</span>
</code></pre></div></div>

<h2 id="orderby-and-groupby">OrderBy and GroupBy</h2>

<p>In SQL queries we often use “order by” and “group by” operations. In Scala we can get the same on collections.</p>

<p>For instance for “order by”:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">fruit</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"pear"</span><span class="o">,</span> <span class="s">"orange"</span><span class="o">,</span> <span class="s">"pineapple"</span><span class="o">)</span>
<span class="n">fruit</span> <span class="nf">sortWith</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">length</span> <span class="o">&lt;</span> <span class="nv">_</span><span class="o">.</span><span class="py">length</span><span class="o">)</span>
<span class="c1">//&gt; res5: List[java.lang.String] = List(pear, apple, orange, pineapple)</span>
<span class="nv">fruit</span><span class="o">.</span><span class="py">sorted</span>
<span class="c1">//&gt; res6: List[java.lang.String] = List(apple, orange, pear, pineapple)</span>
</code></pre></div></div>

<p>And for “group by”:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fruit</span> <span class="nf">groupBy</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">head</span><span class="o">)</span>
<span class="c1">//&gt; res7: scala.collection.immutable.Map[Char,List[java.lang.String]] = </span>
<span class="c1">//&gt; Map(a -&gt; List(apple), o -&gt; List(orange), p -&gt; List(pear, pineapple))</span>
</code></pre></div></div>

<p>Please note that as a result of a <code class="language-plaintext highlighter-rouge">groupBy</code> operation we get a <code class="language-plaintext highlighter-rouge">Map</code> of collections.</p>

<h2 id="map-example-polynom">Map example: Polynom</h2>

<p>A polynomial can be seen as a map from exponents to coefficients:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// x^3 - 2x + 5</span>
<span class="nc">Map</span> <span class="o">(</span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div></div>

<p>So we can create a <code class="language-plaintext highlighter-rouge">Poly</code> class to represent polynomials using maps:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Poly</span><span class="o">(</span><span class="k">val</span> <span class="nv">terms</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Double</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">+</span> <span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Poly</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Poly</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="py">terms</span> <span class="o">++</span> <span class="nv">other</span><span class="o">.</span><span class="py">terms</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span> <span class="k">=</span>
	<span class="o">(</span><span class="nf">for</span> <span class="o">((</span><span class="n">exp</span><span class="o">,</span> <span class="n">coeff</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nv">terms</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">sorted</span><span class="o">.</span><span class="py">reverse</span><span class="o">)</span> <span class="k">yield</span> <span class="n">coeff</span> <span class="o">+</span> <span class="s">"x^"</span> <span class="o">+</span> <span class="n">exp</span><span class="o">)</span> <span class="n">mkString</span> <span class="s">" + "</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But if we now test it we see that additions are not calculated well:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">p1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Poly</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mf">2.0</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mf">4.0</span><span class="o">,</span> <span class="mi">5</span> <span class="o">-&gt;</span> <span class="mf">6.2</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">p2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Poly</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mf">3.0</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mf">7.0</span><span class="o">))</span>
<span class="n">p1</span> <span class="o">+</span> <span class="n">p2</span>
<span class="c1">//&gt; res0: Poly = 6.2x^5 + 7.0x^3 + 2.0x^1 + 3.0x^0</span>
</code></pre></div></div>

<p>Coefficient for x^3 should be 11.0 instead of 7.0. So we obviously have to improve something:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Poly</span><span class="o">(</span><span class="k">val</span> <span class="nv">terms</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Double</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">+</span> <span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Poly</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Poly</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="py">terms</span> <span class="o">++</span> <span class="o">(</span><span class="nv">other</span><span class="o">.</span><span class="py">terms</span> <span class="n">map</span> <span class="n">adjust</span><span class="o">))</span>
  <span class="k">def</span> <span class="nf">adjust</span><span class="o">(</span><span class="n">term</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Double</span><span class="o">))</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
	<span class="nf">val</span> <span class="o">(</span><span class="n">exp</span><span class="o">,</span> <span class="n">coeff</span><span class="o">)</span> <span class="k">=</span> <span class="n">term</span>
	<span class="n">terms</span> <span class="n">get</span> <span class="n">exp</span> <span class="k">match</span> <span class="o">{</span>
	  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">coeff1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">exp</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">coeff</span> <span class="o">+</span> <span class="n">coeff1</span><span class="o">)</span>
	  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">exp</span> <span class="o">-&gt;</span> <span class="n">coeff</span>
	<span class="o">}</span>
  <span class="o">}</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span> <span class="k">=</span>
	<span class="o">(</span><span class="nf">for</span> <span class="o">((</span><span class="n">exp</span><span class="o">,</span> <span class="n">coeff</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nv">terms</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">sorted</span><span class="o">.</span><span class="py">reverse</span><span class="o">)</span> <span class="k">yield</span> <span class="n">coeff</span> <span class="o">+</span> <span class="s">"x^"</span> <span class="o">+</span> <span class="n">exp</span><span class="o">)</span> <span class="n">mkString</span> <span class="s">" + "</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And now it works as expected:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p1</span> <span class="o">+</span> <span class="n">p2</span>
<span class="c1">//&gt; res0: Poly = 6.2x^5 + 11.0x^3 + 2.0x^1 + 3.0x^0</span>
</code></pre></div></div>

<p>But it looks too much work and verbosity to compute just an addition. Remember we said that maps are actually functions. But they are “partial functions” in the sense that applying a map to a key could lead to an exception if that key isn’t included in the map. To avoid this, there is a <code class="language-plaintext highlighter-rouge">withDefaultValue</code> operation that turns a map into a total function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">romanNumbers</span><span class="o">(</span><span class="mi">6</span><span class="o">)</span> <span class="c1">// exception thrown</span>
<span class="k">val</span> <span class="nv">rn</span> <span class="k">=</span> <span class="n">romanNumbers</span> <span class="n">withDefaultValue</span> <span class="s">"-"</span>
<span class="nf">rn</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>  <span class="c1">//&gt; res3: java.lang.String = V</span>
<span class="nf">rn</span><span class="o">(</span><span class="mi">6</span><span class="o">)</span>  <span class="c1">//&gt; res3: java.lang.String = -</span>
</code></pre></div></div>

<p>We can apply this technique to our <code class="language-plaintext highlighter-rouge">Poly</code> class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Poly</span><span class="o">(</span><span class="k">val</span> <span class="nv">terms0</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Double</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">terms</span> <span class="k">=</span> <span class="n">terms0</span> <span class="n">withDefaultValue</span> <span class="mf">0.0</span>
  <span class="k">def</span> <span class="nf">+</span> <span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Poly</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Poly</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="py">terms</span> <span class="o">++</span> <span class="o">(</span><span class="nv">other</span><span class="o">.</span><span class="py">terms</span> <span class="n">map</span> <span class="n">adjust</span><span class="o">))</span>
  <span class="k">def</span> <span class="nf">adjust</span><span class="o">(</span><span class="n">term</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Double</span><span class="o">))</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
	<span class="nf">val</span> <span class="o">(</span><span class="n">exp</span><span class="o">,</span> <span class="n">coeff</span><span class="o">)</span> <span class="k">=</span> <span class="n">term</span>
	<span class="n">exp</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">coeff</span> <span class="o">+</span> <span class="nf">terms</span><span class="o">(</span><span class="n">exp</span><span class="o">))</span>
  <span class="o">}</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span> <span class="k">=</span>
	<span class="o">(</span><span class="nf">for</span> <span class="o">((</span><span class="n">exp</span><span class="o">,</span> <span class="n">coeff</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nv">terms</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">sorted</span><span class="o">.</span><span class="py">reverse</span><span class="o">)</span> <span class="k">yield</span> <span class="n">coeff</span> <span class="o">+</span> <span class="s">"x^"</span> <span class="o">+</span> <span class="n">exp</span><span class="o">)</span> <span class="n">mkString</span> <span class="s">" + "</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Finally, we want to improve the way we create our polynomials, so instead of the first syntax we can use the second:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">p1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Poly</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mf">2.0</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mf">4.0</span><span class="o">,</span> <span class="mi">5</span> <span class="o">-&gt;</span> <span class="mf">6.2</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">p1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Poly</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mf">2.0</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mf">4.0</span><span class="o">,</span> <span class="mi">5</span> <span class="o">-&gt;</span> <span class="mf">6.2</span><span class="o">)</span>
</code></pre></div></div>

<p>This is challenging if we take into account that the number of parameters (in this example, three) could be any number. To achieve this, we need an auxiliary constructor in our class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">this</span><span class="o">(</span><span class="n">bindings</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Double</span><span class="o">)*)</span> <span class="k">=</span> <span class="nf">this</span><span class="o">(</span><span class="nv">bindings</span><span class="o">.</span><span class="py">toMap</span><span class="o">)</span>
</code></pre></div></div>

<p>Where the <code class="language-plaintext highlighter-rouge">*</code> notation means that this is a repeated parameter.</p>

<h2 id="example-translating-phone-numbers-into-sentences">Example: Translating phone numbers into sentences</h2>

<p>Just to recapitulate concepts seen in previous sessions, we are going to work in a more complex example.</p>

<p>Let’s imagine this assignation between numbers in a phone (i.e. an iPhone) and letters:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">mnemonics</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="sc">'2'</span> <span class="o">-&gt;</span> <span class="s">"ABC"</span><span class="o">,</span> <span class="sc">'3'</span> <span class="o">-&gt;</span> <span class="s">"DEF"</span><span class="o">,</span> <span class="sc">'4'</span> <span class="o">-&gt;</span> <span class="s">"GHI"</span><span class="o">,</span> 
                    <span class="sc">'5'</span> <span class="o">-&gt;</span> <span class="s">"JKL"</span><span class="o">,</span> <span class="sc">'6'</span> <span class="o">-&gt;</span> <span class="s">"MNO"</span><span class="o">,</span> <span class="sc">'7'</span> <span class="o">-&gt;</span> <span class="s">"PQRS"</span><span class="o">,</span> 
                    <span class="sc">'8'</span> <span class="o">-&gt;</span> <span class="s">"TUV"</span><span class="o">,</span> <span class="sc">'9'</span> <span class="o">-&gt;</span> <span class="s">"WXYZ"</span><span class="o">)</span>
</code></pre></div></div>

<p>And let’s assume we have a dictionary with a list of words.</p>

<p>Our goal is to design a method <code class="language-plaintext highlighter-rouge">translate</code> such as this call produces this result (and others):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">translate</span><span class="o">(</span><span class="s">"7225247386"</span><span class="o">)</span>
<span class="c1">// Scala is fun</span>
</code></pre></div></div>

<p>Please note that “S” is included in phone key for number 7, “c-a” in key for number 2, “l” in key for number 5, “a” in key for number 2, and so on until “u” and “n” that are in keys for number 8 and 6. So, for each number we have some different letters that we can use to create existing words in our dictionary of words.</p>

<h2 id="final-consideration-on-collections">Final consideration on collections</h2>

<p>Now that we’ve seen some Scala immutable collections it’s a good time to sumarize some of their characteristics:</p>

<ul>
  <li>easy to use: few steps to do the job,</li>
  <li>concise: one word replaces a whole loop,</li>
  <li>safe: type checker is really good at catching errors,</li>
  <li>fast: collection operations are tuned, can be parallelized,</li>
  <li>universal: one vocabulary to work on all kinds of collections.</li>
</ul>

<p>This makes them a very attractive tool for software development.</p>


  </div><a class="u-url" href="/2013/03/12/funprog-week-6-collections.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Email:</li>
          <li>hello <span class="footer-almost-black">at</span> albertmata <span class="footer-almost-black">dot</span> net</li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/almata"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">almata</span></a></li><li><a href="https://www.linkedin.com/in/almata"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">almata</span></a></li><li><a href="https://www.twitter.com/almata"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">almata</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>
          This website does not use any cookie and does not collect any data. Read <a href="/privacy/">Privacy</a> for more information.
          Built with <a href="https://jekyllrb.com">Jekyll</a> and hosted on <a href="https://pages.github.com">GitHub Pages</a>.
          Maintained with ♥ for the web.
        </p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
