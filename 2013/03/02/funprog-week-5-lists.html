<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/assets/main.css">
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Albert Mata</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          <a class="page-link" href="/">Home</a><a class="page-link" href="/notes/">Notes</a><a class="page-link" href="/skills/">Skills</a><a class="page-link" href="/privacy/">Privacy</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">FunProg week 5: Lists</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2013-03-02T00:00:00+01:00" itemprop="datePublished">Mar 2, 2013
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><em>In September 2012, I enrolled in the course <a href="https://www.coursera.org/course/progfun">Functional Programming Principles in Scala</a> given by Martin Odersky at Coursera. In that course I learnt about functional programming and how it can be effectively combined with object-oriented programming. The series [FunProg week] are my compiled notes from that course.</em></p>

<h2 id="lists">Lists</h2>

<p>The list is a fundamental data structure in functional programming. Lists are homogeneous in the sense that all the elements of a list must have the same type.</p>

<p>Lists and arrays have two important differences:</p>

<ul>
  <li>lists are immutable, the elements of a list cannot be changed,</li>
  <li>lists are recursive, while arrays are flat.</li>
</ul>

<p>A list can be created these ways:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">fruit</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"apples"</span><span class="o">,</span> <span class="s">"oranges"</span><span class="o">,</span> <span class="s">"pears"</span><span class="o">)</span>
<span class="k">var</span> <span class="n">diag3</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">empty</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
</code></pre></div></div>

<p>Or also:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">fruit</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"apples"</span><span class="o">,</span> <span class="s">"oranges"</span><span class="o">,</span> <span class="s">"pears"</span><span class="o">)</span>
<span class="k">var</span> <span class="n">diag3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">empty</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
</code></pre></div></div>

<p>Or also:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">fruit</span> <span class="k">=</span> <span class="s">"apples"</span> <span class="o">::</span> <span class="o">(</span><span class="s">"oranges"</span> <span class="o">::</span> <span class="o">(</span><span class="s">"pears"</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">empty</span> <span class="k">=</span> <span class="nc">Nil</span>
</code></pre></div></div>

<p>All lists are actually constructed from the empty list <code class="language-plaintext highlighter-rouge">Nil</code> and the construction operation (<code class="language-plaintext highlighter-rouge">::</code>) that adds an element at the beginning of a list.</p>

<h2 id="right-associativity-of-operators-ending-in-">Right associativity of operators ending in “:”</h2>

<p>In Scala, operators ending in “<code class="language-plaintext highlighter-rouge">:</code>” always associate to the right. So in the previous definitions we just omit the parenthesis and write this instead:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">fruit</span> <span class="k">=</span> <span class="s">"apples"</span> <span class="o">::</span> <span class="s">"oranges"</span> <span class="o">::</span> <span class="s">"pears"</span> <span class="o">::</span> <span class="nc">Nil</span>
<span class="k">val</span> <span class="nv">nums</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="mi">4</span> <span class="o">::</span> <span class="nc">Nil</span>
</code></pre></div></div>

<p>These operators ending in “<code class="language-plaintext highlighter-rouge">:</code>” are seen as method calls of the right-hand operand (instead of the left-hand, which is the standard). So, previous <code class="language-plaintext highlighter-rouge">num</code> expression is actually the same as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Nil</span><span class="o">.::(</span><span class="mi">4</span><span class="o">).::(</span><span class="mi">3</span><span class="o">).::(</span><span class="mi">2</span><span class="o">).::(</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div></div>

<p>These are the three operations more often used when working with lists:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">head</code>, to get the first element of the list,</li>
  <li><code class="language-plaintext highlighter-rouge">tail</code>, to get the list composed of all the elements except the first,</li>
  <li><code class="language-plaintext highlighter-rouge">isEmpty</code>, to check if the list is empty or not.</li>
</ul>

<h2 id="list-patterns">List patterns</h2>

<p>We can use the pattern matching technique we saw in previous chapters with lists. A pattern <code class="language-plaintext highlighter-rouge">Nil</code> will match an empty list. A pattern <code class="language-plaintext highlighter-rouge">p :: ps</code> will match a list with a <code class="language-plaintext highlighter-rouge">head</code> matching <code class="language-plaintext highlighter-rouge">p</code> and a <code class="language-plaintext highlighter-rouge">tail</code> matching <code class="language-plaintext highlighter-rouge">ps</code>. For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="n">xs</span>  <span class="c1">// list starting with 1 and then 2</span>
<span class="n">x</span> <span class="o">::</span> <span class="nc">Nil</span>      <span class="c1">// list of length 1</span>
<span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>       <span class="c1">// list of length 1</span>
<span class="nc">List</span><span class="o">()</span>        <span class="c1">// empty List</span>
<span class="nc">Nil</span>           <span class="c1">// empty list</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">2</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="c1">// list with only one element, which is another list that starts with 2</span>
</code></pre></div></div>

<h2 id="example-sorting-lists">Example: sorting lists</h2>

<p>Let’s create a new method to sort a list of integers in ascending order. The idea is that, given a list, we can sort it by adding the head element in the right place in the sorted tail. This sorted tail will have been sorted using same algorithm, so it’s obviously a recursive algorithm.</p>

<p>Here’s the code for this O(N*N) implementation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">isort</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">()</span>
  <span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span> <span class="nf">insert</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="nf">isort</span><span class="o">(</span><span class="n">ys</span><span class="o">))</span>
<span class="o">}</span> 

<span class="k">def</span> <span class="nf">insert</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="nf">insert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="some-list-methods">Some list methods</h2>

<p>Let’s see some useful methods for working with lists (a full list of methods can be found at <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.List">Scala Standard Library</a>):</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">xs.length</code> returns the number of elements in the list,</li>
  <li><code class="language-plaintext highlighter-rouge">xs.last</code> returns the list’s last element,</li>
  <li><code class="language-plaintext highlighter-rouge">xs.init</code> returns a list with all the elements but the last,</li>
  <li><code class="language-plaintext highlighter-rouge">xs take n</code> returns a list with the first n elements,</li>
  <li><code class="language-plaintext highlighter-rouge">xs drop n</code> returns the rest of the collection after taking the first n elements,</li>
  <li><code class="language-plaintext highlighter-rouge">xs(n)</code> (or <code class="language-plaintext highlighter-rouge">xs apply n</code>) returns the nth element in the list,</li>
  <li><code class="language-plaintext highlighter-rouge">xs ++ ys</code> returns a list joining two (in the order they appear),</li>
  <li><code class="language-plaintext highlighter-rouge">xs.reverse</code> returns the list with all the elements in reversed order,</li>
  <li><code class="language-plaintext highlighter-rouge">xs updated (n, x)</code> returns the same list but changing the nth element for <code class="language-plaintext highlighter-rouge">x</code>,</li>
  <li><code class="language-plaintext highlighter-rouge">xs indexOf x</code> returns the index of the first element in the list equal to <code class="language-plaintext highlighter-rouge">x</code> (-1 if <code class="language-plaintext highlighter-rouge">x</code> is not in the list),</li>
  <li><code class="language-plaintext highlighter-rouge">xs contains x</code> says if the list contains the <code class="language-plaintext highlighter-rouge">x</code> element.</li>
</ul>

<p>Some of these methods can throw exceptions if we ask for non existing elements (i.e. the last element of an empty list).</p>

<p>It’s important to keep in mind the complexity of each method we use when working with lists. Some of them can ve very efficient while others maybe are not so much.</p>

<h2 id="pairs-and-tuples">Pairs and tuples</h2>

<p>To introduce pairs and tuples, we’re going to work with a different (and more efficient) sorting algorithm. In concrete, we’re going to implement the <a href="http://en.wikipedia.org/wiki/Merge_sort">merge sort algorithm</a>.</p>

<p>In it, we start with a long list and separate it into two sub-lists, each containing around half of the elements of the original list. Then we recursively sort the two sub-lists same way and finally we merge the two sorted sub-lists into a single sorted list. This well known algorithm works pretty fine.</p>

<p>A first implementation of it is as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">msort1</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
  <span class="k">else</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
	  <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="n">ys</span>
	  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span> <span class="k">=&gt;</span> <span class="n">ys</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="n">xs</span>
		<span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys1</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
						 <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys1</span><span class="o">)</span>
	  <span class="o">}</span>
	<span class="o">}</span>
	<span class="nf">val</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
	<span class="nf">merge</span><span class="o">(</span><span class="nf">msort1</span><span class="o">(</span><span class="n">fst</span><span class="o">),</span> <span class="nf">msort1</span><span class="o">(</span><span class="n">snd</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If we take a look at the code, we can see we’ve used the <code class="language-plaintext highlighter-rouge">splitAt</code> function. This function on lists returns two sublists: one with the elements up to the given index and another with the elements from that index. And this two lists are returned in a pair.</p>

<p>In Scala we can define pairs just by writing two values in parenthesis:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">pair1</span> <span class="k">=</span> <span class="o">(</span><span class="s">"answer"</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">pair2</span> <span class="k">=</span> <span class="o">(</span><span class="sc">'a'</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">pair3</span> <span class="k">=</span> <span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">30</span><span class="o">)</span>

<span class="c1">// pair1 type is (String, Int)</span>
<span class="c1">// pair2 type is (Char, Int)</span>
<span class="c1">// pair3 type is (Int, Int)</span>
</code></pre></div></div>

<p>And pairs can also be used as patterns, meaning that we can now do this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">val</span> <span class="o">(</span><span class="n">label</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="k">=</span> <span class="n">pair1</span>
</code></pre></div></div>

<p>And <code class="language-plaintext highlighter-rouge">label</code> will take “answer” as its value and <code class="language-plaintext highlighter-rouge">value</code> wil take 42.</p>

<p>Another way to access the values of a pair is as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">label</span> <span class="k">=</span> <span class="nv">pair1</span><span class="o">.</span><span class="py">_1</span>
<span class="k">val</span> <span class="nv">value</span> <span class="k">=</span> <span class="nv">pair1</span><span class="o">.</span><span class="py">_2</span>
</code></pre></div></div>

<p>This all works analogously for tuples with more than two elements. Actually a pair is just a tuple with two elements.</p>

<p>Now that we know how pairs work, we can rewrite our merge sort algorithm using a pattern matching over pairs:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">msort2</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
  <span class="k">else</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
	  <span class="nf">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ys</span>
	  <span class="nf">case</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">xs</span>
	  <span class="nf">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
								   <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys1</span><span class="o">)</span>
	<span class="o">}</span>
	<span class="nf">val</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
	<span class="nf">merge</span><span class="o">(</span><span class="nf">msort2</span><span class="o">(</span><span class="n">fst</span><span class="o">),</span> <span class="nf">msort2</span><span class="o">(</span><span class="n">snd</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="generics-and-type-parameters">Generics and type parameters</h2>

<p>In our previous example we have this function signature:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">msort</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>That, of course, only works with <code class="language-plaintext highlighter-rouge">Int</code> types. We could try this other signature using generics:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">msort</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</code></pre></div></div>

<p>But it wouldn’t work because we use the comparison <code class="language-plaintext highlighter-rouge">&lt;</code> inside the function, and this comparison is not defined for arbitrary types <code class="language-plaintext highlighter-rouge">T</code>. To make it work, we need to parameterize the function with the necessary comparison function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">msort</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">lt</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="nf">merge</span><span class="o">(</span><span class="nf">msort</span><span class="o">(</span><span class="n">fst</span><span class="o">)(</span><span class="n">lt</span><span class="o">),</span> <span class="nf">msort</span><span class="o">(</span><span class="n">snd</span><span class="o">)(</span><span class="n">lt</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="nf">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys1</span><span class="o">)</span> <span class="k">=&gt;</span>
	<span class="nf">if</span> <span class="o">(</span><span class="nf">lt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span> <span class="o">...</span>
	<span class="k">else</span> <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Roughly, we are introducing a new parameter with is a less-than function (<code class="language-plaintext highlighter-rouge">lt</code>) that takes two <code class="language-plaintext highlighter-rouge">T</code> elements and returns a <code class="language-plaintext highlighter-rouge">Boolean</code> saying if the first is less than the second. With that, now any kind of <code class="language-plaintext highlighter-rouge">T</code> element can be compared.</p>

<p>So, the full code for this function is as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">msort1</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">lt</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
  <span class="k">else</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
	  <span class="nf">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ys</span>
	  <span class="nf">case</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">xs</span>
	  <span class="nf">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="nf">lt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span> <span class="n">x</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
								   <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys1</span><span class="o">)</span>
	<span class="o">}</span>
	<span class="nf">val</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
	<span class="nf">merge</span><span class="o">(</span><span class="nf">msort1</span><span class="o">(</span><span class="n">fst</span><span class="o">)(</span><span class="n">lt</span><span class="o">),</span> <span class="nf">msort1</span><span class="o">(</span><span class="n">snd</span><span class="o">)(</span><span class="n">lt</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now we can compare any kind of types just giving a valid comparison function. For instance, for integers we can sort a list this way:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">myList</span> <span class="k">=</span> <span class="o">-</span><span class="mi">4</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">5</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="o">-</span><span class="mi">9</span> <span class="o">::</span> <span class="nc">Nil</span>
<span class="nf">msort1</span><span class="o">(</span><span class="n">myList</span><span class="o">)((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span>
<span class="c1">//&gt; res0: List[Int] = List(-9, -4, 1, 2, 3, 5)</span>
</code></pre></div></div>

<p>But if we wanted to sort from big to small, it would be trivial:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">msort1</span><span class="o">(</span><span class="n">myList</span><span class="o">)((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">)</span>        
<span class="c1">//&gt; res1: List[Int] = List(5, 3, 2, 1, -4, -9)</span>
</code></pre></div></div>

<p>Or if we wanted to sort taking into account the absolute value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">msort1</span><span class="o">(</span><span class="n">myList</span><span class="o">)((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">abs</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">&lt;</span> <span class="nf">abs</span><span class="o">(</span><span class="n">y</span><span class="o">))</span>
<span class="c1">//&gt; res2: List[Int] = List(1, 2, 3, -4, 5, -9)</span>
</code></pre></div></div>

<p>And the functions works same way for other types of data:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">myFruits</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"pineapple"</span><span class="o">,</span> <span class="s">"orange"</span><span class="o">,</span> <span class="s">"banana"</span><span class="o">)</span>
<span class="nf">msort1</span><span class="o">(</span><span class="n">myFruits</span><span class="o">)((</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">x</span><span class="o">.</span><span class="py">compareTo</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="c1">//&gt; res3: List[java.lang.String] = List(apple, banana, orange, pineapple)</span>
</code></pre></div></div>

<p>Finally, Scala can infere the data types from the first parameter of <code class="language-plaintext highlighter-rouge">msort</code> function, so the last expression can also be written as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">msort1</span><span class="o">(</span><span class="n">myFruits</span><span class="o">)((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">x</span><span class="o">.</span><span class="py">compareTo</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div></div>

<p>That’s actually possible because the function parameter is the last one. So it’s generally a good idea to put function parameters after type parameters, so the Scala compiler can infere the type parameters for the function parameter.</p>

<h2 id="parameterization-with-ordering">Parameterization with Ordering</h2>

<p>There is already a class in the standard library that represents orderings: <code class="language-plaintext highlighter-rouge">scala.math.Ordering[T]</code>. It contains the <code class="language-plaintext highlighter-rouge">lt</code> function, but some other useful ones.</p>

<p>So we actually could rewrite our <code class="language-plaintext highlighter-rouge">msort</code> function this other way using it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">msort2</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> 
  <span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
  <span class="k">else</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
	  <span class="nf">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ys</span>
	  <span class="nf">case</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">xs</span>
	  <span class="nf">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">ord</span><span class="o">.</span><span class="py">lt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span> <span class="n">x</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
								   <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys1</span><span class="o">)</span>
	<span class="o">}</span>
	<span class="nf">val</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
	<span class="nf">merge</span><span class="o">(</span><span class="nf">msort2</span><span class="o">(</span><span class="n">fst</span><span class="o">)(</span><span class="n">ord</span><span class="o">),</span> <span class="nf">msort2</span><span class="o">(</span><span class="n">snd</span><span class="o">)(</span><span class="n">ord</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And then use it as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">msort2</span><span class="o">(</span><span class="n">myList</span><span class="o">)(</span><span class="nv">Ordering</span><span class="o">.</span><span class="py">Int</span><span class="o">)</span>
<span class="c1">//&gt; res5: List[Int] = List(-9, -4, 1, 2, 3, 5)</span>
<span class="nf">msort2</span><span class="o">(</span><span class="n">myFruits</span><span class="o">)(</span><span class="nv">Ordering</span><span class="o">.</span><span class="py">String</span><span class="o">)</span>
<span class="c1">//&gt; res6: List[java.lang.String] = List(apple, banana, orange, pineapple)</span>
</code></pre></div></div>

<h2 id="implicit-parameters">Implicit parameters</h2>

<p>But if we know that most of the times when we call <code class="language-plaintext highlighter-rouge">msort</code> function with integers or strings we are using the standard comparison function, wouldn’t be better if we could just avoid that parameter? Yes, we can do it using an implicit parameter:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">msort3</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> 
  <span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
  <span class="k">else</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
	  <span class="nf">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ys</span>
	  <span class="nf">case</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">xs</span>
	  <span class="nf">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">ord</span><span class="o">.</span><span class="py">lt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span> <span class="n">x</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
								   <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys1</span><span class="o">)</span>
	<span class="o">}</span>
	<span class="nf">val</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
	<span class="nf">merge</span><span class="o">(</span><span class="nf">msort3</span><span class="o">(</span><span class="n">fst</span><span class="o">),</span> <span class="nf">msort3</span><span class="o">(</span><span class="n">snd</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here we are telling the compiler to use our explicit comparison <code class="language-plaintext highlighter-rouge">Ordering</code> if we specify one, or an implicit one if we do not. So we can call this function in different ways and we’ll get the same result we got before:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">msort3</span><span class="o">(</span><span class="n">myFruits</span><span class="o">)</span>
<span class="nf">msort3</span><span class="o">(</span><span class="n">myFruits</span><span class="o">)(</span><span class="nv">Ordering</span><span class="o">.</span><span class="py">String</span><span class="o">)</span>
</code></pre></div></div>

<p>Only thing to take into account when working with implicit parameters is that a visible and type compatible definition has to be available in the point where it’s required. Otherwise an error will be thrown.</p>

<h2 id="higher-order-list-functions">Higher order list functions</h2>

<p>In previous chapters we talked about higher order functions and said that “in functional programming, functions can be passed as a parameter to another function and returned as a result as well, which provides a very flexible way to compose programs. The functions that take other functions as parameters or that return functions as results are called higher order functions (as opposite to first order functions, which are the standard functions that just work on simple data types). So, functions that operate on other functions (accept them as arguments) or return other functions are called higher order functions. The idea behind this is that when we see that a particular piece of code is repeated in different functions, we can break it out into a new function and then write higher order functions that use it. Or, seen from a different point of view, when a piece of logic within our function needs to behave differently in different situations, we can break it out into a higher order function that uses different functions in each situation. In fact,  we get a higher degree of granularity with less code.”</p>

<p>Now that we are working with lists we can see several recurring patterns, like:</p>

<ul>
  <li>transforming each element in a list in a certain way,</li>
  <li>retrieving a list of all elements satisfying a criterion,</li>
  <li>combining the elements of a list using an operator.</li>
</ul>

<h2 id="transformation-of-lists">Transformation of lists</h2>

<p>We can write generic functions that implement patterns such as these using higher order functions.</p>

<p>For instance, to multiply each element of a list by the same factor we can write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">scaleList1</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">],</span> <span class="n">factor</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="n">xs</span>
  <span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span> <span class="n">y</span> <span class="o">*</span> <span class="n">factor</span> <span class="o">::</span> <span class="nf">scaleList1</span><span class="o">(</span><span class="n">ys</span><span class="o">,</span> <span class="n">factor</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But as that is a quite common pattern, there is a <code class="language-plaintext highlighter-rouge">map</code> method in the <code class="language-plaintext highlighter-rouge">List</code> class to do exactly that same thing:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">scaleList2</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">],</span> <span class="n">factor</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">xs</span> <span class="nf">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factor</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="getting-sublists">Getting sublists</h2>

<p>Another example is selecting all elements in a list satisfying a given condition (i.e. numbers greater than zero). We can create a function by ourselves:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">posElems1</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="n">xs</span>
  <span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">y</span> <span class="o">::</span> <span class="nf">posElems1</span><span class="o">(</span><span class="n">ys</span><span class="o">)</span> <span class="k">else</span> <span class="nf">posElems1</span><span class="o">(</span><span class="n">ys</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Or we can use the <code class="language-plaintext highlighter-rouge">filter</code> method in the <code class="language-plaintext highlighter-rouge">List</code> class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">posElems2</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">xs</span> <span class="nf">filter</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div></div>

<p>There are some other methods to extract sublists based on a boolean predicate:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">xs filterNot p</code> returns a sublist with the elements that don’t satisfy the predicate,</li>
  <li><code class="language-plaintext highlighter-rouge">xs partition p</code> returns a pair <code class="language-plaintext highlighter-rouge">(xs filter p, xs filterNot p)</code> but computed in a single traversal of the list (instead of two),</li>
  <li><code class="language-plaintext highlighter-rouge">xs takeWhile p</code> returns the longest sublist at the beginning of the list such that the predicate is true (so all elements until the first not satisfying the predicate),</li>
  <li><code class="language-plaintext highlighter-rouge">xs dropWhile p</code> returns the remainder of the list not taken by <code class="language-plaintext highlighter-rouge">takeWhile</code>,</li>
  <li><code class="language-plaintext highlighter-rouge">xs span p</code> returns a pair <code class="language-plaintext highlighter-rouge">(xs takeWhile p, xs dropWhile p)</code>.</li>
</ul>

<p>A full list of methods can be found at <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.List">Scala Standard Library</a>.</p>

<h2 id="reduction-of-lists">Reduction of lists</h2>

<p>Another common operation on lists is to combine its elements using a given operator. For instance, for the sum:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sum1</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="mi">0</span>
  <span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span> <span class="n">y</span> <span class="o">+</span> <span class="nf">sum1</span><span class="o">(</span><span class="n">ys</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But we can also use the <code class="language-plaintext highlighter-rouge">reduceLeft</code> method that inserts a given binary operator between adjacent elements of a list:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sum2</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="nf">reduceLeft</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">0 :: xs</code> is to be sure an empty list will give a correct result (0).</p>

<p>We’re using a lot little functions like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div></div>

<p>These functions are actually so used that there is a shorter way to write them:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>In this syntax, every <code class="language-plaintext highlighter-rouge">_</code> represents a new parameter, going from left to right.</p>

<p>So we could write previous function <code class="language-plaintext highlighter-rouge">sum</code> as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sum3</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="nf">reduceLeft</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">reduceLeft</code> method is actually defined in terms of a more general function: <code class="language-plaintext highlighter-rouge">foldLeft</code>. This function is very similar, but takes an accumulator as an additional parameter and returns it when called on an empty list.</p>

<p>So, using <code class="language-plaintext highlighter-rouge">foldLeft</code> in our <code class="language-plaintext highlighter-rouge">sum</code> function this would be the final code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sum4</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="n">xs</span> <span class="n">foldLeft</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="foldright-and-reduceright">foldRight and reduceRight</h2>

<p>As seen, <code class="language-plaintext highlighter-rouge">foldLeft</code> and <code class="language-plaintext highlighter-rouge">reduceLeft</code> unfold on trees that lean to the left. This means that the operands are taken beginning from the left. Analogously, we have <code class="language-plaintext highlighter-rouge">foldRight</code> and <code class="language-plaintext highlighter-rouge">reduceRight</code> that do the opposite: produce trees which lean to the right, or take the operands beginning from the right.</p>

<p>With sums and products both versions return the same result, as they are associative and commutative, but with other operations they do not. For instance:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">myList</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mf">10.0</span><span class="o">,</span> <span class="mf">5.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)</span>
<span class="n">myList</span> <span class="nf">reduceLeft</span> <span class="o">(</span><span class="k">_</span> <span class="o">/</span> <span class="k">_</span><span class="o">)</span>  <span class="c1">// 1.0</span>
<span class="n">myList</span> <span class="nf">reduceRight</span> <span class="o">(</span><span class="k">_</span> <span class="o">/</span> <span class="k">_</span><span class="o">)</span> <span class="c1">// 4.0</span>
</code></pre></div></div>


  </div><a class="u-url" href="/2013/03/02/funprog-week-5-lists.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Email:</li>
          <li>hello <span class="footer-almost-black">at</span> albertmata <span class="footer-almost-black">dot</span> net</li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/almata"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">almata</span></a></li><li><a href="https://www.linkedin.com/in/almata"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">almata</span></a></li><li><a href="https://www.twitter.com/almata"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">almata</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>
          This website does not use any cookie and does not collect any data. Read <a href="/privacy/">Privacy</a> for more information.
          Built with <a href="https://jekyllrb.com">Jekyll</a> and hosted on <a href="https://pages.github.com">GitHub Pages</a>.
          Maintained with ♥ for the web.
        </p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
